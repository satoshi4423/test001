オペレーティングシステム
	ハードウェアの複雑さを隠すためのソフトウェア階層

	プログラム　fileに保存　osが動かすという手順を踏んでいる。

	ただ単にモーターを動かすときにほかの割り込みなどが入ったりするので、ハードウェアをいじる人は邪魔に感じる可能性あり。

仕事
	抽象化　
	メモリのアドレスに書き込んでいるわけで、電流を直接流しているわけではない。
	メモリの読み書きのように動かすことが出来る。

	OS　fileによる抽象化
	マイコン的なものをOSが受け持ち、ユーザーがなるべく触れないようになる。
	メモリアドレスを指定するのではなく、ピンの名前で行けるようにする

	リソース管理　多人数作業など
	
	よくよく考えると、機械の操作はデータを書いてデータを読みことで済む。
	BUT余計なオーバーヘッドが生まれる。重たくなる。

	file例
	乱数生成期　ゴミ捨て場(入力しても保存されない)

	プロセス
	複数のプログラムを実行可能
	OSなしではできない
	恩恵もあるが複雑になる。機器を同時に使うので通信制御が必要

OS　なんでもファイルを扱い、プロセスを同時に走らせるための物らしい
Githabはなぜソフトウェアを公開するのか


unix以前　科学計算や集計に利用されていた。　
　オペレーターはもらったやつを実行していた。　今はOSがやっている仕事
当然ながらロボットには組み込めない。

プラグボード　配線でプログラムしていた
パンチカード　

一台の計算機で一つの計算しかできない
	割り込みのないマイコン

マルチタスク最初期
　メモリパーティション分け（固定）した　（まだまだパンチカード）
　パンチカードを覚える記憶装置が必要(まだファイルではない)


その後メモリのパーティションが動的に

成功する秘訣
オープンソースで作ると人が集まると協力が大きい
上からしゃしゃり出てくる人が老害がいないと成功する
タイミング

リナックスは、本体(カーネル)めちゃくちゃ少ない？とディストリビューションで構成されている

ディストリビューションはとても種類がある。
主なディストリビューションの3代けいとう
red hat

slackware

debian
調べておこう



ソフトウェアは隠して売る　公開する　という選択肢
亜種の発生は技術より社会的な理由（らいせんす) 

我々は無数の開発者が作ったものをubuntuを通して利用している




